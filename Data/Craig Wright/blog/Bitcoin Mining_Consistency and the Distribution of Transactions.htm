					<h1 class="entry-title">Bitcoin Mining: Consistency and the Distribution of Transactions</h1>
										<div class="post-details">
						<span>By Jasred Hope Bargan</span> | <span>28 Apr 2016</span> | <span class="txt-color-brown">Bitcoin &amp; Blockchain Tech</span>
					</div>
					<hr width="100" class="sep">
						<h5><em>Misunderstandings in the bitcoin community have led to false conclusions about the way that bitcoin works. The bitcoin mining process is fundamentally competitive, and personal gains are made through competition, regardless of how it appears. The complex reality is counter-intuitive, but understanding the differences among miners’ approaches to processing can disabuse us of the notion of a ‘standard’ block. Comparing the bitcoin to Hashcash eliminates false beliefs about the bitcoin hashing algorithm, verifies that each individual block is unique, and demonstrates that each individual miner acts independently of the others.</em></h5>
<p>Many common but false beliefs in the bitcoin community have led to common misunderstandings, such as the ‘selfish miner attack’ [1]. Some of these beliefs arise from misunderstandings about the bitcoin block. These misunderstandings have led, in turn, to false conclusions on blocksize debates and an incorrect understanding of the way that bitcoin works. Simply put, there is no such thing as a consistent block before it is mined and included within the chain.</p>
<p><img class="alignnone size-full wp-image-16658" src="./Craig Wright - Bitcoin Mining_ Consistency and the Distribution of Transactions_files/Bitcoin-strategy.png" alt="" width="1015" height="585" srcset="https://craigwright.net/wp-content/uploads/2016/04/Bitcoin-strategy.png 1015w, https://craigwright.net/wp-content/uploads/2016/04/Bitcoin-strategy-300x173.png 300w, https://craigwright.net/wp-content/uploads/2016/04/Bitcoin-strategy-768x443.png 768w" sizes="(max-width: 1015px) 100vw, 1015px"></p>
<p>In fact, a consistent block is not even maintained across a single mining entity, let alone across a pool of miners or in the overall network. Individual blocks are not consistent series of transactions with a nonce; rather, each block is a series of transactions that changes moment by moment. In addition, there is no need for consistency within a block before it is mined. Each attempt to solve the next block remains independent of the previous attempt. Therefore, adding a transaction to a block has no effect on the overall time required for solving that block. The result is that individual miners experience discrepancies in the information that they are solving.</p>
<p>The order in which miners receive information leads to radically different solutions to the block puzzle. For example, if two miners were to receive two separate transactions that were released from slightly different locations and at slightly different times, it is likely that one miner would exhibit a different transactional order than the other miner in the block that they were attempting to solve.</p>
<p>The original bitcoin paper [2] notes transactional order within blocks, particularly on pages 2, 3, and 4. The error of using this format for describing unmined blocks derives from a misunderstanding of the bitcoin code implementation. The paper describes&nbsp;<strong><u>solved</u></strong>&nbsp;blocks, in which the transaction order is fixed. The nature of the hashing algorithm is such that any alteration or change to the order [3] creates a widely divergent numerical output. This means that changing the order of Tx0, Tx1, and other transactions in a solved block leads to a widely divergent hash unlikely to represent a solution to the hashing puzzle that, therefore, would not be considered a validly mined block.</p>
<p>What seems to be misunderstood here is that separate miners can mine transactional data in any order. The addition of a nonce to seek a solution provides miners with the ability to add verified transactions in any order while they equally and fairly compete&nbsp;using&nbsp;their levels of computational power. As a consequence, miners do not benefit by pruning transactions in blocks or by seeking a common ordering of transactions. If a miner were to seek to align a transactional order with other miners, the likely result would be a scenario in which any miner seeking to align transactional positions would be economically disadvantaged due to the extra cost of this pre-processing.</p>
<p>Furthermore, a miner who selects random transactional orders based on the time of receipt of each transaction would have a slight advantage and be able to apply the computational power that he or she controls to solving more hash puzzles than miners who seek an aligned strategy. The costs of coordinating transactions among miners add latency to the communications as well as a high degree of inefficiency. In such a process, a miner would need to discard many possible solutions&nbsp;that&nbsp;could be solved while negotiating a consistent strategy with other miners.</p>
<p>The mining process is competitive. Miners seek to maximise their personal gains by competing with other miners. The competitive process verifies and disseminates a consistent ledger throughout the system.</p>
<h3>WHAT IS A BLOCK?</h3>
<p>A block does not emerge until a hash puzzle has been solved. In attempting to solve a proof or work a puzzle, each miner takes a set of transactions, adds a timestamp, and then adds a nonce. This is a highly simplified version of what actually occurs, but this process captures the basics of the block creation process. For several reasons, there is flexibility in the timestamping protocol. First, there is latency between nodes and, more importantly, exact timekeeping is not required. Nodes are allowed some variation in their system times if they remain within an acceptable range. The time range function used by bitcoin mirrors several authentication protocols such as Kerberos [4] but with a wider drift range. Bitcoin is a far more forgiving protocol [6].</p>
<p>The bitcoin protocol is designed to allow for a wide range of time discrepancies, and it discards any discovered block that incorporates a timestamp outside its large defined range. This range is calculated based on two factors.</p>
<p>1. The timestamp in a block must be larger than the <a href="http://mathworld.wolfram.com/StatisticalMedian.html">median</a> distance from the timestamps recorded in the previous 11 mined blocks.<br>
2. It must be lower than the ‘network-adjusted time’ plus 7,200 seconds.</p>
<p>Note that the median timestamping function has a limiting adjustment in which a difference limit of 4,200 seconds is the maximum possible adjustment allowed.</p>
<p>Each node polls the nodes to which it is connected using a ‘network-adjusted time’ function, which is calculated using the median of the timestamps returned by all the nodes connected to the local node.</p>
<p><img class="size-full wp-image-16644 alignnone" src="./Craig Wright - Bitcoin Mining_ Consistency and the Distribution of Transactions_files/B0001-IMG_2.png" alt="" width="519" height="114" srcset="https://craigwright.net/wp-content/uploads/2019/06/B0001-IMG_2.png 519w, https://craigwright.net/wp-content/uploads/2019/06/B0001-IMG_2-300x66.png 300w" sizes="(max-width: 519px) 100vw, 519px"></p>
<p>Thus, a block is formed from the proof of work (PoW) solution to the ordered transaction data. This incorporates four items.</p>
<p>1. A set of transactions that can be in any order, although each order comprises a separate possible solution to the hash puzzle.<br>
2. A timestamp that is limited in range by the bitcoin time adjustment functions and that is accurate to the second.<br>
3. The 256-bit hash of the preceding block, which limits the discovery of a solution to the proof of the work puzzle to the chain of discovered blocks. With this limitation, there is no way that an attacker can circumvent the PoW limitations by pre-mining or adding targeted solutions.<br>
4. A nonce sufficient to limit the hash of the block cannot exceed the current <a href="https://en.bitcoin.it/wiki/Target">difficulty target.</a></p>
<p>The timestamp function utilized in the block structure is an open-source IEC 61850 ‘uint32_t’ implementation [5]. The accuracy of this function is derived as a 32-bit calculation of the number of seconds since 1970. It differs from the ‘uint64_t’ bit value because ‘uint32_t’ is accurate to the second whereas ‘uint64_t’ is accurate&nbsp;to the millisecond. Because this is an unsigned integer, the bitcoin network supports twice the total number of seconds as the standard Unix time format.</p>
<p>There are standardized orders to the way that the blocks are presented, but the protocol allows for a wide variety of methodologies for solving the hash puzzle of an individual block.</p>
<p><img class="size-full wp-image-16645 alignnone" src="./Craig Wright - Bitcoin Mining_ Consistency and the Distribution of Transactions_files/B001-Image3.jpg" alt="" width="979" height="617" srcset="https://craigwright.net/wp-content/uploads/2019/06/B001-Image3.jpg 979w, https://craigwright.net/wp-content/uploads/2019/06/B001-Image3-300x189.jpg 300w, https://craigwright.net/wp-content/uploads/2019/06/B001-Image3-768x484.jpg 768w" sizes="(max-width: 979px) 100vw, 979px"></p>
<h3>AN ALTERNATIVE STRATEGY</h3>
<p>It is highly unlikely that we would find the following strategy used by a miner because it is more difficult to ensure sorting order than to update a nonce. However, we present it for illustrative purposes.</p>
<p>It is feasible to set a standard nonce that is never updated and update the order of transactions. Each possible ordering of transactions in a possible block solution will lead to a separate proof or attempt at a work solution. Simply changing the order of transactions without updating the nonce is, in itself, a way to create a new hash value that can be checked against the PoW difficulty requirements. Reordering of transactions is a combinatorial permutation problem [6]. The difficulty with this scheme would be in creating a system faster than the existing mining solutions based on ASIC hardware.</p>
<p>The number of possible solutions to a reordering of transactions is derived from a factorial calculation of the number of transactions in the possible block. Moreover, because there is a wide range of acceptable timestamps, these could be adjusted to each possible solution based on permutations in the time range to further extend the number of possible PoW solutions. Ignoring the increased number of permutations that derive from a change in timestamps, we can calculate the number of possible permutations that can be used as a possible block solution as follows:</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">=</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped">(</span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span><span class="style-wrap reset-textstyle textstyle uncramped">)</span></span><span class="mclose">!</span></span></span></span></p>
<p>where&nbsp;<em><span class="katex"><span class="katex-mathml">n</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></em> indicates the number of possible permutations obtained through reordering transactions and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>&nbsp;indicates the set of combinational permutations of the transactions for block&nbsp;<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>.</p>
<p>If we estimate the maximum number of transactions in a 1MB block to be defined as (1) five transactions/second and (2) 600 seconds (average)/block, we obtain 3,000 transactions/block, which equates to n = [(ti)!] = 3000! = 4.149 x 10<sup>9130</sup> possible transaction combinations even before accounting for the timestamps. A more accurate calculation based on existing conditions would be derived through a range based on the existing moving average target of the mean&nbsp;<a href="https://www.blockchain.com/charts/n-transactions-per-block?">rate of transactions that are included in a block</a>. At the time of writing, this range is 1,049–1,760 with an expected range based on <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">α</span><span class="mrel">=</span><span class="mord mathrm">5</span><span class="mord mathrm">%</span></span></span></span>&nbsp;confidence interval.</p>
<p>At this level, we still observe the range of permutations in the order of [1.343×10<sup>​2715</sup>​​,5.833×10<sup>​4949</sup>​​] permutations. Even at the lower bound, this order of difficulty exceeds the calculations of the hash itself. In fact, the lowest number of transactions that have been included in a block in the previous two-year period was 248 transactions. At this volume, the number of combinations would be n=5.193×10<sup>487</sup>.</p>
<p>Through this exercise, we can quickly recognize that the probability of two mining nodes working on the same transaction order at the same time is phenomenally small. It is more likely that the same SHA-256 value would be returned as a collision between two separate blocks than within a single block to be calculated in two locations.</p>
<p>This logic might seem counterintuitive to many people because it seems likely that each miner would process the same transaction data in the same order. However, reality is more complex. If a transaction were broadcast close to one mining node and were more distant, in terms of latency, than another, then there would be a delay in the receipt of the transaction at the more distant node.</p>
<p>When we then incorporate other transactions that might be closer to the second node than to the first node, we can quickly obtain an intuitive understanding of the differences in ordering. At node 1, we would expect the following order to result,</p>
<p>Tx0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tx1;</p>
<p>at node 2, we would expect the order to be</p>
<p>Tx1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tx0.</p>
<p><img class="size-full wp-image-16646 alignnone" src="./Craig Wright - Bitcoin Mining_ Consistency and the Distribution of Transactions_files/B0001-IMG_4.png" alt="" width="783" height="684" srcset="https://craigwright.net/wp-content/uploads/2019/06/B0001-IMG_4.png 783w, https://craigwright.net/wp-content/uploads/2019/06/B0001-IMG_4-300x262.png 300w, https://craigwright.net/wp-content/uploads/2019/06/B0001-IMG_4-768x671.png 768w" sizes="(max-width: 783px) 100vw, 783px"></p>
<p>The change is extremely small, but the important thing is that, even if this change were a single transactional difference in the entire block, it would lead to a completely different hash value. When each of the nodes calculates the hash value of these two transactions, the numerical outcome will not be the same and, because this is propagated through the Merkle route calculation, the value that is finally returned in the block as the&nbsp;<strong><em>hashMerkleRoot</em></strong>&nbsp;will be completely different for each node.</p>
<p>Widespread misunderstanding of this point has led to the common belief that a particular block is competitively solved. However, the fact is that no standard block exists before the solution of the PoW through the addition of a nonce with the corresponding values of the blockhead that must be included.</p>
<p>This error in understanding leads to the false belief that a node can hide information from other nodes to gain a competitive advantage. Two nodes each independently attempt to solve a PoW puzzle, but this puzzle is independent in each instance [8]. Therefore, the problem is a competing Poisson problem. The rate of discovery for a mining node is defined by λ​<sub>1</sub>​​, where the rate of discovery is set to&nbsp;<span class="katex"><span class="katex-mathml">{\lambda _2}</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span>&nbsp;for the sum of all other nodes in the network.</p>
<p>Together, we obtain a rate for an individual mining node of λ<sub>1</sub>/λ<sub>1</sub> + λ<sub>2</sub><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="mfrac"><span class="vlist"><span class=""><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5">​</span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span>. For example, if we had a large mining pool with 1/3<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="mfrac"><span class="vlist"><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span> of the total computational power of a given difficulty period, we would have a value of λ​&lt;sub&lt;1<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="vlist"><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathrm">2</span></span></span></span> and λ​<sub>2</sub>​​<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mrel">=</span><span class="mord mathrm">4</span></span></span></span> for the corresponding nodes. This result derives from the expected discovery rates. The mining pool with 1/3<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="mfrac"><span class="vlist"><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span> of the total hashrate would be expected to solve two blocks per hour from a system with a difficulty that overall leads to six blocks being solved (on average) per hour. This results in the remainder of the mining nodes solving <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit">λ</span><span class="mbin">−</span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span>, or four blocks. The overall system discovery rate would be defined in the protocol as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">λ</span><span class="mrel">=</span><span class="mord mathrm">6</span></span></span></span>.</p>
<p>One of the properties of the Poisson process is in an area referred to as ‘competing processes’. If we assume that N<sub>1</sub> (t), t <span style="text-decoration: underline;">&gt;</span> 0 and N<sub>2</sub> (t), t <span style="text-decoration: underline;">&gt;</span> 0&nbsp;are independent Poisson processes with the respective rates of <span class="katex"><span class="katex-mathml">\lambda</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">λ</span></span></span></span>&nbsp;and&nbsp;<span class="katex"><span class="katex-mathml">{\lambda _2}</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span>&nbsp;(as defined above), and we let&nbsp;<span class="katex"><span class="katex-mathml">S_n^i</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">S</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span>&nbsp;represent the&nbsp;<span class="katex"><span class="katex-mathml">{n^{th}}</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span class=""><span class="fontsize-ensurer reset-size5 size5">​</span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">h</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="">​</span></span>​</span></span></span></span></span></span></span>&nbsp;event (or discovery of a valid block) for process&nbsp;<span class="katex"><span class="katex-mathml">i, j = 1, 2</span><span class="katex-html" aria-hidden="true"><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mord mathit">j</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span></span></span></span>, then we have the well-known condition [9, 10, 11]:</p>
<p><img class="size-full wp-image-16656 alignnone" src="./Craig Wright - Bitcoin Mining_ Consistency and the Distribution of Transactions_files/equation.png" alt="" width="523" height="56" srcset="https://craigwright.net/wp-content/uploads/2016/04/equation.png 523w, https://craigwright.net/wp-content/uploads/2016/04/equation-300x32.png 300w" sizes="(max-width: 523px) 100vw, 523px"></p>
<p>This equation can be used to determine the probability of a node calculating one or more blocks before the rest of the network.</p>
<h3>THE HASHING ALGORITHM USED IN BITCOIN.</h3>
<p>There is a common, but false, belief that Adam Back is the original source of the hash puzzle used in bitcoin. This belief derives from the paper’s references to ‘Hashcash’ [2]. Instead, we find the base algorithm defined on page 4 of ‘DOS-resistant authentication with client puzzles’ [12]. The authors did not release code, and a modified protocol and code were used in the bitcoin core release of 2009.</p>
<p>The original implementation of Hashcash is available via the&nbsp;<a href="http://www.cypherspace.org/adam/hashcash/">Internet Archive project here</a>&nbsp;and the&nbsp;<a href="http://www.cypherspace.org/adam/hashcash/hashcash.pdf">original code here.</a>&nbsp;The false belief that&nbsp;<a href="https://web.archive.org/web/20160502204234/http://www.cypherspace.org/adam/">Hashcash was ‘used as the mining function in bitcoin</a>’ can be quickly dispelled by comparing the codes used in each.</p>
<p>This exercise will demonstrate that the variables and functions written for bitcoin, such as&nbsp;<em>nTotalLower</em>&nbsp;and&nbsp;<em>nTargetValue</em>, differ radically from the functions used in Hashcash.</p>
<p>It was implemented simply in bitcoin, where comparisons, such as the following, were used instead of schemes that are more difficult to implement:</p>
<p><em>if(hash &lt;= hashTarget)</em></p>
<p><em>{pblock-&gt;nNonce = tmp.block.nNonce;</em></p>
<p><em>assert(hash == pblock-&gt;GetHash());</em></p>
<p>and</p>
<p><em>// Check proof of work matches claimed amount</em></p>
<p><em>if(CBigNum().SetCompact(nBits) &gt; bnProofOfWorkLimit)</em></p>
<p><em>return error(“CheckBlock() : nBits below minimum work”);</em></p>
<p><em>if(GetHash() &gt; CBigNum().SetCompact(nBits).getuint256())</em></p>
<p><em>return error(“CheckBlock() : hash doesn’t match nBits”);</em></p>
<p>Other methods, including seeking matched hash collisions, such as are found in Hashcash, could have been incorporated; but this would have involved additional changes that would have made the initial implementation of bitcoin more difficult. The originally incorporated code derives from implementations developed by Wei Dai and Steve Reid.</p>
<h3>BLOCKS ARE UNIQUE</h3>
<p>What the reader should take away from this exercise is that each individual block is unique. This has become more complicated since the introduction of mining pools, in which groups of individual miners act in a concerted manner to solve a shared problem. However, that scenario does not change the way that transactions are distributed in a block. The effect is that each mining pool mimics a large mining node.</p>
<p>To many people, it seems counterintuitive; however, it is critically important to remember that each individual miner acts independently of all other miners in the system. What is even more counterintuitive is that each individual attempt is completely independent and unrelated to all previous attempts. Each attempt to solve a bitcoin block puzzle is like a coin toss in the sense that the results are truly independent from all other coin tosses.</p>
<h3>REFERENCES</h3>
<table>
<tbody>
<tr>
<td width="94">[1]</td>
<td width="507">I. Eyal, &amp; E. Gun Sirer, “<a href="https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf" target="_blank" rel="noopener noreferrer">Majority is not Enough: Bitcoin Mining is Vulnerable</a>” 2013</td>
</tr>
<tr>
<td width="94">[2]</td>
<td width="507">“<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">Bitcoin: A Peer-to-Peer Electronic Cash System</a>” 2008</td>
</tr>
<tr>
<td width="94">[3]</td>
<td width="507">J.S. Coron, Y. Dodis, C. Malinaud, P. Puniya. “Merkle-Damgård revisited: How to construct a hash function.” In Advances in Cryptology–CRYPTO 2005, 2005 Aug 14 (pp. 430-448). Springer Berlin Heidelberg</td>
</tr>
<tr>
<td width="94">[4]</td>
<td width="507">C. Neuman, T. Yu, S. Hartman, &amp; K. Raeburn,“<a href="https://www.ietf.org/rfc/rfc4120.txt" target="_blank" rel="noopener noreferrer">The Kerberos Network Authentication Service &nbsp;(V5)</a>,” Network Working Group, <a class="libx-autolink" href="http://tools.ietf.org/html/rfc4120">RFC 4120</a>,&nbsp;2005</td>
</tr>
<tr>
<td width="94">[5]</td>
<td width="507"><a href="http://libiec61850.com/api/" target="_blank" rel="noopener noreferrer"><span style="color: #333333;">“Open-source IEC 61850 MMS/GOOSE server and client library”</span></a></td>
</tr>
<tr>
<td width="94">[6]</td>
<td width="507">TechNet, Viewed from:&nbsp;<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc779260(v=ws.10)" target="_blank" rel="noopener noreferrer">“Maximum tolerance for computer clock synchronization”</a>, 2005</td>
</tr>
<tr>
<td width="94">[7]</td>
<td width="507">L. Lovasz, “Combinatorial Problems and Exercises,” Publishing House of the Hungarian Academy of Sciences, Budapest, 1979</td>
</tr>
<tr>
<td width="94">[8]</td>
<td width="507">W. Feller, “An introduction to probability theory and its applications,” 1957</td>
</tr>
<tr>
<td width="94">[9]</td>
<td width="507">M. S. Bartlett. “An Introduction to Stochastic Processes, with Special Reference to Methods and Applications.” Cambridge University Press, Cambridge/New York, 1980</td>
</tr>
<tr>
<td width="94">[10]</td>
<td width="507">A. Stuart. “Kendall’s Advanced Theory of Statistics.” Wiley, Chichester, 1994</td>
</tr>
<tr>
<td width="94">[11]</td>
<td width="507">U. Narayan Bhat and G. K. Miller. “Elements of Applied Stochastic Processes.” Wiley-Interscience, Hoboken, N.J. 2002</td>
</tr>
<tr>
<td width="94">[12]</td>
<td width="507">Aura, Tuomas, Pekka Nikander, and Jussipekka Leiwo. “DOS-resistant authentication with client puzzles.” In Security Protocols, pp. 170-177. Springer Berlin Heidelberg, 2000</td>
</tr>
</tbody>
</table>